# Phase 1-3: Core, Grid, Elements — Реализация

## Обзор

Базовая инфраструктура Match3: данные, сетка, элементы. 10 файлов, ~500 строк кода.

```
Assets/Scripts/
├── Core/
│   └── GridPosition.cs       # Координаты сетки
├── Data/
│   ├── ElementType.cs        # SO типа элемента
│   └── GridConfig.cs         # SO конфигурации
├── Grid/
│   ├── GridData.cs           # Логика сетки
│   ├── GridPositionConverter.cs  # Grid ↔ World
│   └── GridView.cs           # Визуал сетки
└── Elements/
    ├── IElement.cs           # Интерфейс
    ├── ElementView.cs        # MonoBehaviour
    ├── ElementPool.cs        # Пул объектов
    └── ElementFactory.cs     # Фабрика
```

---

## Phase 1: Core Data Structures

### 1.1 GridPosition

**Файл:** `Assets/Scripts/Core/GridPosition.cs`

Immutable struct для координат на сетке. Используется везде вместо Vector2Int для type safety.

```csharp
// Создание
var pos = new GridPosition(3, 5);

// Арифметика
var neighbor = pos + GridPosition.Right;  // (4, 5)
var delta = posA - posB;

// Направления
GridPosition.Up      // (0, 1)
GridPosition.Down    // (0, -1)
GridPosition.Left    // (-1, 0)
GridPosition.Right   // (1, 0)

// Итерация по соседям
foreach (var dir in GridPosition.Directions)
{
    var neighbor = pos + dir;
}

// Сравнение
if (posA == posB) { }
```

**Почему struct, а не class:**
- Value type — нет аллокаций в heap
- Immutable — безопасно передавать
- Используется как ключ в Dictionary/HashSet

---

### 1.2 ElementType (ScriptableObject)

**Файл:** `Assets/Scripts/Data/ElementType.cs`

Определяет тип элемента (красный, синий, etc). Создаётся в Unity: `Create → Match3 → Element Type`

```csharp
// Поля (настраиваются в Inspector)
string Id           // "red", "blue", etc
Sprite Sprite       // Визуал
Color Color         // Тинт (по умолчанию белый)
GameObject DestroyVfxPrefab  // VFX при уничтожении (опционально)
AudioClip DestroySound       // Звук (опционально)
```

**Использование:**
```csharp
// Сравнение типов
if (elementA.Type == elementB.Type) { /* match! */ }

// Получение визуала
spriteRenderer.sprite = elementType.Sprite;
spriteRenderer.color = elementType.Color;
```

**Setup в Unity:**
1. `Create → Match3 → Element Type`
2. Назвать: Red, Blue, Green, Yellow, Purple
3. Назначить спрайты и цвета
4. Добавить в GridConfig

---

### 1.3 GridConfig (ScriptableObject)

**Файл:** `Assets/Scripts/Data/GridConfig.cs`

Центральная конфигурация игры. Создаётся: `Create → Match3 → Grid Config`

```csharp
// Grid Size
int Width = 8           // Колонки
int Height = 8          // Строки
float CellSize = 1f     // Размер ячейки в world units

// Animation
float SwapDuration = 0.2f      // Длительность свапа (сек)
float FallSpeed = 10f          // Скорость падения (ячеек/сек)
float DestroyDuration = 0.15f  // Длительность уничтожения

// Elements
ElementType[] ElementTypes     // 5 типов элементов
```

**Использование:**
```csharp
// Доступ к конфигу через GridView
var config = gridView.Config;
var grid = new GridData(config.Width, config.Height);

// Случайный тип
var randomType = config.ElementTypes[Random.Range(0, config.ElementTypes.Count)];
```

---

## Phase 2: Grid System

### 2.1 GridData

**Файл:** `Assets/Scripts/Grid/GridData.cs`

Pure C# класс — логическое состояние сетки. Хранит 2D массив элементов.

```csharp
// Создание
var grid = new GridData(width: 8, height: 8);

// Проверка границ
if (grid.IsValidPosition(pos)) { }

// Получение элемента
IElement element = grid.GetElement(pos);  // null если пусто

// Установка элемента (fires OnElementSet)
grid.SetElement(pos, element);

// Удаление (fires OnElementRemoved)
grid.RemoveElement(pos);

// Свап (НЕ fires events — для валидации)
grid.SwapElements(posA, posB);

// Все пустые позиции
List<GridPosition> empty = grid.GetEmptyPositions();
```

**События:**
```csharp
grid.OnElementSet += (pos, element) => { /* element placed */ };
grid.OnElementRemoved += (pos) => { /* element removed */ };
```

**Почему Pure C#, а не MonoBehaviour:**
- Легко тестировать
- Нет Unity lifecycle overhead
- Можно сериализовать/сохранять отдельно

---

### 2.2 GridPositionConverter

**Файл:** `Assets/Scripts/Grid/GridPositionConverter.cs`

Конвертация между grid координатами и world позициями.

```csharp
// Создание (обычно через GridView)
var converter = new GridPositionConverter(cellSize: 1f, gridOrigin: Vector2.zero);

// Grid → World
Vector3 worldPos = converter.GridToWorld(new GridPosition(3, 5));

// World → Grid (округляет к ближайшей ячейке)
GridPosition gridPos = converter.WorldToGrid(worldPos);
```

**Формула:**
```
worldX = originX + gridX * cellSize
worldY = originY + gridY * cellSize
```

---

### 2.3 GridView (MonoBehaviour)

**Файл:** `Assets/Scripts/Grid/GridView.cs`

Визуальное представление сетки. Создаёт фоновые ячейки.

**Inspector поля:**
```csharp
[SerializeField] GridConfig _config;        // Конфиг (обязательно)
[SerializeField] SpriteRenderer _cellPrefab; // Префаб ячейки (опционально)
[SerializeField] Transform _cellsParent;     // Родитель для ячеек
```

**API:**
```csharp
// Свойства
GridConfig Config { get; }
GridPositionConverter PositionConverter { get; }

// Создать визуальную сетку
gridView.CreateVisualGrid();

// Событие
gridView.OnGridReady += () => { /* grid created */ };
```

**Центрирование:**
GridView автоматически центрирует сетку относительно своего transform. Ячейка (0,0) будет в левом нижнем углу.

**Setup в Unity:**
1. Создать пустой GameObject "Grid"
2. Добавить компонент `GridView`
3. Назначить GridConfig
4. (Опционально) Создать префаб ячейки фона

---

## Phase 3: Element System

### 3.1 IElement (Interface)

**Файл:** `Assets/Scripts/Elements/IElement.cs`

Контракт для игровых элементов.

```csharp
public interface IElement
{
    ElementType Type { get; }              // Тип элемента
    GridPosition Position { get; set; }    // Позиция на сетке
    Transform Transform { get; }           // Unity Transform

    void Initialize(ElementType type, GridPosition position);
    void PlayDestroyAnimation(Action onComplete);
    void MoveTo(Vector3 worldPosition, float duration, Action onComplete = null);
}
```

**Зачем интерфейс:**
- Абстракция от конкретной реализации
- Легко мокать в тестах
- Можно создать разные типы элементов (бонусы, блокеры)

---

### 3.2 ElementView (MonoBehaviour)

**Файл:** `Assets/Scripts/Elements/ElementView.cs`

Реализация IElement. Использует DOTween для анимаций.

**Inspector:**
```csharp
[SerializeField] SpriteRenderer _spriteRenderer;  // Обязательно
```

**Анимации:**
```csharp
// Движение (свап, падение)
element.MoveTo(targetWorldPos, duration: 0.2f, onComplete: () => { });

// Уничтожение (scale to zero)
element.PlayDestroyAnimation(onComplete: () => {
    // вернуть в пул
});
```

**Prefab Setup:**
1. Создать пустой GameObject
2. Добавить SpriteRenderer (child или на том же объекте)
3. Добавить компонент `ElementView`
4. Назначить SpriteRenderer в Inspector
5. Сохранить как Prefab

---

### 3.3 ElementPool (MonoBehaviour)

**Файл:** `Assets/Scripts/Elements/ElementPool.cs`

Object pooling для переиспользования элементов.

**Inspector:**
```csharp
[SerializeField] ElementView _prefab;     // Префаб элемента
[SerializeField] int _initialSize = 64;   // Начальный размер пула
```

**API:**
```csharp
// Получить элемент (активирует GameObject)
ElementView element = pool.Get();

// Вернуть в пул (деактивирует, сбрасывает scale)
pool.Return(element);
```

**Как работает:**
- В Awake создаёт `_initialSize` элементов
- При Get() берёт из очереди или создаёт новый
- При Return() деактивирует и возвращает в очередь

---

### 3.4 ElementFactory (MonoBehaviour)

**Файл:** `Assets/Scripts/Elements/ElementFactory.cs`

Фабрика для создания элементов. Обёртка над пулом.

**Inspector:**
```csharp
[SerializeField] ElementPool _pool;           // Пул
[SerializeField] Transform _elementsParent;   // Родитель для элементов
```

**API:**
```csharp
// Создать элемент
IElement element = factory.CreateElement(
    type: redElementType,
    position: new GridPosition(3, 5),
    worldPos: new Vector3(3, 5, 0)
);

// Вернуть в пул
factory.ReturnElement(element);
```

---

## Scene Setup

### Иерархия объектов:

```
Scene
├── Main Camera
├── Grid                    [GridView]
│   └── Cells              (parent for background cells)
├── ElementPool            [ElementPool]
│   └── (pooled elements)
├── Elements               (parent for active elements)
└── ElementFactory         [ElementFactory]
```

### Порядок настройки:

1. **Создать ScriptableObjects:**
   - `Assets/Data/GridConfig.asset`
   - `Assets/Data/Elements/Red.asset`, Blue, Green, Yellow, Purple

2. **Создать префабы:**
   - `Assets/Prefabs/Element.prefab` (с ElementView + SpriteRenderer)
   - `Assets/Prefabs/Cell.prefab` (опционально, для фона)

3. **Настроить сцену:**
   - Grid GameObject + GridView (назначить GridConfig)
   - ElementPool (назначить Element prefab)
   - ElementFactory (назначить Pool и Elements parent)

---

## Пример использования

```csharp
public class GameBootstrap : MonoBehaviour
{
    [SerializeField] private GridView _gridView;
    [SerializeField] private ElementFactory _factory;

    private GridData _gridData;

    void Start()
    {
        // Создать данные сетки
        var config = _gridView.Config;
        _gridData = new GridData(config.Width, config.Height);

        // Создать визуальную сетку
        _gridView.CreateVisualGrid();

        // Заполнить элементами (пример)
        for (int x = 0; x < config.Width; x++)
        {
            for (int y = 0; y < config.Height; y++)
            {
                var pos = new GridPosition(x, y);
                var worldPos = _gridView.PositionConverter.GridToWorld(pos);
                var type = config.ElementTypes[Random.Range(0, config.ElementTypes.Count)];

                var element = _factory.CreateElement(type, pos, worldPos);
                _gridData.SetElement(pos, element);
            }
        }
    }
}
```

---

## Следующие шаги

**Phase 4: Spawn System** — заполнение без начальных матчей
**Phase 5: Match Detection** — поиск линий 3+
